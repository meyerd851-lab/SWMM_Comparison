<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SWMM Comparison App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicon for the app (space encoded) -->
  <link rel="icon" type="image/png" href="SWMM%20Comparison%20App%20Icon.png">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- proj4 for EPSG:3735 -> WGS84 -->
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.11.0/dist/proj4.js"></script>

  <style>
    :root { --blue:#05275a; --gray:#7f8c8d; --green:#2ecc71; --red:#e74c3c; --orange:#f39c12;}
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { font-family: Segoe UI, system-ui, sans-serif; margin:0; color:#222; font-size: 14px; }
    header { display: flex; align-items: center; gap:10px; padding: 0 14px; height: 50px; background:var(--blue); color: #fff; border-bottom:1px solid #e3e3e3; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    h1 { margin:0; font-size:18px; color: #fff; }
    header img { height: 28px; width: 28px; }
    header > .btn-group { display:flex; gap: 4px; }
    #app-title-group { margin-left: auto; display: flex; align-items: center; gap: 10px; }

    /* New Dropdown Menu Styles */
    .menu { position: relative; }
    .menu-btn { padding: 6px 12px; border-radius: 6px; cursor: pointer; font-weight: 500; color: #fff; }
    .menu-btn:hover { background-color: #fff; color: #000; }
    .menu-content {
      display: none; position: absolute; top: 100%; left: 0; background: #fff;
      border: 1px solid #ccc; box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 4px; color: #222;
      min-width: 200px; z-index: 1000; padding: 4px;
    }
    .menu:hover .menu-content { display: block; }
    .menu-item { display: block; width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; border-radius: 4px; }
    .menu-item:hover { background-color: #eef3ff; color: var(--blue); }
    .menu-content hr { border: none; border-top: 1px solid #eee; margin: 4px 0; }
    .menu-content label { display: block; padding: 8px 12px; }

    input[type=file]{ display: none; } /* Hide default file inputs */
    button { padding:8px 12px; border-radius:8px; border:1px solid #d0d0d0; background:#fff; cursor:pointer; font-size: 14px; }
    button.primary{ background:#fff; color:var(--blue); border-color:#fff; font-weight: 600; }
    #wrap { display:grid; grid-template-columns: 340px 1fr; gap:12px; padding:12px; height: calc(100vh - 51px); min-height:0; }

    /* New styles for dropdown-like buttons and file inputs */
    .dropdown-btn, .file-btn-label {
      padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.5); background: transparent; color: #fff; cursor: pointer;
      display: inline-flex; align-items: center; gap: 8px;
    }
    .dropdown-btn::after {
      content: '▼'; font-size: 8px; opacity: 0.6;
    }
    .dropdown-btn:hover, .file-btn-label:hover { background-color: #f8f8f8; color: #222; }

    .diff { background:#fff6e6; border:1px solid #ffe0a8; border-radius:4px; padding:1px 4px; }
    .arrow { opacity:0.75; }
    .removedCell { color:#a52222; }
    .addedCell { color:#1e7b3a; }

    #left { display:grid; grid-template-rows: minmax(0, 1fr) minmax(0, 1fr); gap:12px; min-height:0; }
    .panel { border:1px solid #e1e1e1; border-radius:8px; background:#fff; padding:10px; min-height:0; display:flex; flex-direction:column; }
    .panel h3 { margin:0 0 8px 0; font-size:14px; color:#333; }
    #summaryPanel, #sectionsPanel { overflow:auto; }
    #summary, #sections { overflow:auto; min-height:0; }
    #sections .sec { padding:6px 8px; border-radius:6px; cursor:pointer; display:flex; justify-content:space-between; align-items:center; }
    .sec:hover { background:#f6f6f9; }
    .sec.active { background:#eef3ff; border:1px solid #d9e3ff; }
    .counts { color:#666; font-size:12px; }

    #right { display:flex; flex-direction:column; min-height:0; }
    #filters { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #search { flex:1; min-width:140px; padding:6px 8px; border:1px solid #ddd; border-radius:6px; }
    #detailsWrap { display:flex; gap:12px; min-height:0; }
    #tableWrap { flex:1; min-width:0; min-height:0; }
    #map { width:45%; min-width:360px; min-height:0; border:1px solid #e1e1e1; border-radius:8px; }

    #table { width:100%; border-collapse: collapse; font-size:13px; }
    #table th, #table td { border:1px solid #eee; padding:6px 8px; text-align:left; vertical-align:top; }
    #table th { background:#fafafa; position: sticky; top: 0; z-index:1; }
    #tableContainer { overflow:auto; height:100%; border:1px solid #e1e1e1; border-radius:8px; }

    .chip{display:inline-block;width:10px;height:10px;border-radius:2px;margin-right:6px;vertical-align:middle;}
    .legend{position:absolute; bottom:12px; left:12px; background:#fff; padding:10px 12px; border:1px solid #ccc; border-radius:8px; font-size:12px; box-shadow:0 1px 4px rgba(0,0,0,.08);}
    .pill { padding:2px 6px; border-radius:999px; font-size:12px; font-weight:600; }
    .pill.added { background:#eaf7ef; color:#1e7b3a; border:1px solid #cdeed6; }
    .pill.removed { background:#fdeaea; color:#a52222; border:1px solid #f7c7c7; }
    .pill.changed { background:#fff6e6; color:#935c00; border:1px solid #ffe0a8; }
    .row { cursor:pointer; }
    .row:hover { background:#f6f9ff; }
    #status { color:rgba(255,255,255,0.85); }

    #modalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:9999;}
    #modal{background:#fff;border-radius:10px;border:1px solid #ddd;max-width:900px;width:90vw;max-height:80vh;display:flex;flex-direction:column;}
    #modal header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid #eee}
    #modal h2{margin:0;font-size:16px}
    #modal .body{padding:10px 14px;overflow:auto}
    #modal .foot{display:flex;gap:8px;justify-content:flex-end;padding:10px 14px;border-top:1px solid #eee}
    .cell-changed{background:#fff6e6;border:1px solid #ffe0a8;border-radius:6px;padding:2px 4px}
    .kv{display:grid;grid-template-columns:200px 1fr 1fr;gap:6px;align-items:start}
    .kv div{padding:6px 8px;border-bottom:1px solid #f2f2f2}
    .kv .hdr{font-weight:600;background:#fafafa}
    .tag{display:inline-block;background:#eef3ff;border:1px solid #d9e3ff;color:#2b579a;border-radius:999px;padding:2px 8px;font-size:12px}

    /* Hydrograph modal table polish */
    table.modal-hydro { width:100%; border-collapse:separate; border-spacing:0; }
    table.modal-hydro thead th {
      background:#fafafa; border-bottom:1px solid #eee; padding:8px 10px; text-align:left;
      position:sticky; top:0; z-index:1;
    }
    table.modal-hydro tbody td { padding:6px 10px; border-top:1px solid #f4f4f4; }
    table.modal-hydro tbody tr:nth-child(odd) { background:#fcfcfe; }
    table.modal-hydro .resp { font-weight:600; white-space:nowrap; }
    table.modal-hydro .num { font-variant-numeric: tabular-nums; text-align:right; display:inline-block; min-width:3ch; }
    table.modal-hydro .delta {
      display:inline-flex; align-items:center; gap:6px;
      background:#fff6e6; border:1px solid #ffe0a8; border-radius:8px; padding:2px 6px;
      font-variant-numeric: tabular-nums;
    }
    table.modal-hydro .old { opacity:.75; text-decoration:line-through; }
    table.modal-hydro .arrow { opacity:.6; }
    table.modal-hydro .diff { font-weight:600; }
    table.modal-hydro .plusminus { opacity:.7; }

    /* Desktop-ish legend look */
    .legend-title { font-weight:700; margin-bottom:6px; color:#333; }
    .lg-item { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .lg-swatch { width:16px; height:6px; border-radius:3px; display:inline-block; border:1px solid rgba(0,0,0,.2); }
    .lg-unchanged { background: var(--gray); }
    .lg-changed { background: var(--orange); }
    .lg-added   { background: var(--green); }
    .lg-removed { background: var(--red); }

    /* Map label badges */
    .map-label {
      background: rgba(255,255,255,.85);
      border: 1px solid rgba(0,0,0,.25);
      border-radius: 3px;
      padding: 1px 4px;
      font-size: 11px;
      line-height: 1.2;
      color: #222;
      white-space: nowrap;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <header>
    <div class="menu">
      <div class="menu-btn">File</div>
      <div class="menu-content">
        <button id="saveSess" class="menu-item">Save Session</button>
        <button id="loadSessBtn" class="menu-item">Load Session</button>
        <input id="loadSessInput" type="file" accept=".json" />
      </div>
    </div>
    <div class="menu">
      <div class="menu-btn">Map</div>
      <div class="menu-content">
        <label>Basemap:
          <select id="basemapSelect" title="Basemap" style="width:100%; margin-top:4px; padding: 4px;">
            <option value="street" selected>Street</option>
            <option value="aerial">Aerial</option>
            <option value="none">None</option>
          </select>
        </label>
        <hr>
        <label class="menu-item"><input type="checkbox" id="labelsToggle"> Show Labels</label>
      </div>
    </div>

    <div class="btn-group">
      <label for="f1" class="file-btn-label">First INP</label>
      <input id="f1" type="file" accept=".inp,.txt" />
      <label for="f2" class="file-btn-label">Second INP</label>
      <input id="f2" type="file" accept=".inp,.txt" />
    </div>
    <button id="go" class="primary">Compare</button>
    <span id="status"></span>
    <div id="app-title-group">
      <h1>SWMM Comparison App</h1>
      <img src="SWMM%20Comparison%20App%20Icon.png" alt="App Icon">
    </div>
  </header>

  <div id="wrap">
    <div id="left">
      <div id="summaryPanel" class="panel">
        <h3>Summary</h3>
        <div id="summary">No results yet.</div>
      </div>

      <div id="sectionsPanel" class="panel">
        <h3>Sections</h3>
        <div id="sections">Run a comparison first.</div>
      </div>
    </div>

    <div id="right">
      <div class="panel" style="gap:8px;">
        <div id="filters">
          <label><input type="checkbox" id="fAdded" checked> Added</label>
          <label><input type="checkbox" id="fRemoved" checked> Removed</label>
          <label><input type="checkbox" id="fChanged" checked> Changed</label>
          <input id="search" placeholder="Filter rows…" />
          <span id="currentSectionLabel" style="color:#333;font-weight:600;"></span>
        </div>
      </div>

      <div id="detailsWrap" style="flex:1;">
        <div id="tableWrap" class="panel" style="flex:1; display:flex; flex-direction:column; min-height:0;">
          <h3 style="margin-bottom:8px;">Details</h3>
          <div id="tableContainer"><table id="table"></table></div>
        </div>

        <div id="map" class="panel"></div>
      </div>
    </div>
  </div>

  <!-- Legend replaced with desktop-styled version -->
  <template id="legend">
    <div class="legend">
      <div class="legend-title">Map Legend</div>
      <div class="lg-item"><span class="lg-swatch lg-unchanged"></span><span>Unchanged</span></div>
      <div class="lg-item"><span class="lg-swatch lg-changed"></span><span>Changed</span></div>
      <div class="lg-item"><span class="lg-swatch lg-added"></span><span>Added</span></div>
      <div class="lg-item"><span class="lg-swatch lg-removed"></span><span>Removed</span></div>
    </div>
  </template>

  <div id="modalBackdrop" onclick="if(event.target===this) closeModal()">
    <div id="modal" role="dialog" aria-modal="true">
      <header>
        <h2 id="modalTitle">Details</h2>
        <button onclick="closeModal()">Close</button>
      </header>
      <div class="body">
        <div id="modalMeta" style="margin-bottom:8px;color:#555;"></div>
        <div class="kv" id="modalGrid"></div>
      </div>
      <div class="foot">
        <label style="margin-right:auto"><input type="checkbox" id="onlyChangedBox" /> Show changed fields only</label>
        <button onclick="copyRowJSON()">Copy JSON</button>
      </div>
    </div>
  </div>

  <script>
    proj4.defs("EPSG:3735",
      "+proj=lcc +lat_0=38 +lon_0=-82.5 +lat_1=40.0333333333333 +lat_2=38.7333333333333 +x_0=600000 +y_0=0 +ellps=GRS80 +units=us-ft +no_defs +type=crs"
    );

    // Test the transformation
    console.log("Test EPSG:3735 transformation:", xyToLatLng(1968500, 0));

    // Session logic
    const SESSION_VERSION = 1;

    // Keep the last-picked INP files in memory so we can save them into the session
    let FILES = { f1Name:null, f2Name:null, f1Bytes:null, f2Bytes:null };

    function abToB64(ab) {
      const bytes = new Uint8Array(ab);
      let binary = '';
      const chunkSize = 0x8000; // 32 KB chunks
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }

    function b64ToAb(b64){
      const bin = atob(b64);
      const ab = new ArrayBuffer(bin.length);
      const view = new Uint8Array(ab);
      for (let i=0;i<bin.length;i++) view[i] = bin.charCodeAt(i);
      return ab;
    }

    async function saveSession(){
      if (!LAST.json) { alert("Run a comparison first."); return; }

      const session = {
        version: SESSION_VERSION,
        createdUtc: new Date().toISOString(),
        files: {
          file1: FILES.f1Bytes ? { name: FILES.f1Name, bytesB64: abToB64(FILES.f1Bytes) } : null,
          file2: FILES.f2Bytes ? { name: FILES.f2Name, bytesB64: abToB64(FILES.f2Bytes) } : null,
        },
        result: LAST.json,
        ui: {
          section: LAST.currentSection || null,
          filters: {
            Added:   document.getElementById('fAdded').checked,
            Removed: document.getElementById('fRemoved').checked,
            Changed: document.getElementById('fChanged').checked,
            Search:  document.getElementById('search').value || ""
          }
        }
      };

      const blob = new Blob([JSON.stringify(session, null, 2)], { type: "application/json" });

      if (window.showSaveFilePicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: `inp_diff_session_${Date.now()}.json`,
            types: [{
              description: 'INP Diff Session',
              accept: { 'application/json': ['.json'] }
            }]
          });
          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();
          setStatus("Session saved.");
        } catch (err) {
          if (err.name !== 'AbortError') console.error("Save failed:", err);
        }
      } else {
        // Fallback for older browsers
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `inp_diff_session_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    function applyUIState(ui){
      if (!ui) return;
      const f = ui.filters || {};
      if (typeof f.Added   === 'boolean')  document.getElementById('fAdded').checked = f.Added;
      if (typeof f.Removed === 'boolean')  document.getElementById('fRemoved').checked = f.Removed;
      if (typeof f.Changed === 'boolean')  document.getElementById('fChanged').checked = f.Changed;
      if (typeof f.Search  === 'string')   document.getElementById('search').value = f.Search;
    }

    // Header relabel for INFILTRATION
    function relabelHeaders(section, hdrs){
      if (section !== "INFILTRATION") return hdrs;
      const MAP = {
        "Param1": "Max. Infil. Rate",
        "Param 1": "Max. Infil. Rate",
        "Param2": "Min. Infil. Rate",
        "Param 2": "Min. Infil. Rate",
        "Param3": "Decay Constant",
        "Param 3": "Decay Constant",
        "Param4": "Drying Time",
        "Param 4": "Drying Time",
        "Param5": "Max. Volume",
        "Param 5": "Max. Volume",
      };
      return hdrs.map(h => MAP[h] ?? h);
    }

    function restoreFromResult(result, ui){
      LAST.json = result;
      renderSummary(result.summary);
      renderSections(result);
      drawGeometry(result);
      applyUIState(ui);
      if (ui?.section && result.diffs[ui.section]) {
        LAST.currentSection = ui.section;
        document.getElementById('currentSectionLabel').textContent = ui.section;
        renderTableFor(ui.section);
        const node = [...document.querySelectorAll('.sec')].find(n => n.dataset.sec === ui.section);
        document.querySelectorAll('.sec').forEach(n=>n.classList.remove('active'));
        node?.classList.add('active');
      }
      setStatus("Session loaded.");
    }

    async function loadSession(file){
      try {
        const text = await file.text();
        const session = JSON.parse(text);

        FILES = { f1Name:null, f2Name:null, f1Bytes:null, f2Bytes:null };
        if (session.files?.file1?.bytesB64) {
          FILES.f1Name  = session.files.file1.name || "file1.inp";
          FILES.f1Bytes = b64ToAb(session.files.file1.bytesB64);
        }
        if (session.files?.file2?.bytesB64) {
          FILES.f2Name  = session.files.file2.name || "file2.inp";
          FILES.f2Bytes = b64ToAb(session.files.file2.bytesB64);
        }

        if (session.result) {
          restoreFromResult(session.result, session.ui);
        } else if (FILES.f1Bytes && FILES.f2Bytes) {
          setStatus("Recomputing comparison from saved INP files…");
          worker.postMessage({ type:"compare", file1: FILES.f1Bytes, file2: FILES.f2Bytes }, [FILES.f1Bytes, FILES.f2Bytes]);
        } else {
          alert("Session file has no result data and no embedded INP files. Please select the INP files and run Compare.");
        }
      } catch (e) {
        console.error(e);
        alert("Could not load session: " + e.message);
      }
    }

    // Wire up
    document.getElementById('saveSess').addEventListener('click', saveSession);
    document.getElementById('loadSessBtn').addEventListener('click', ()=> document.getElementById('loadSessInput').click());
    document.getElementById('loadSessInput').addEventListener('change', (ev)=>{
      const f = ev.target.files?.[0];
      if (f) loadSession(f);
    });

    // Capture file bytes when the user selects them
    document.getElementById('go').addEventListener('click', async ()=>{
      const f1 = document.getElementById('f1').files?.[0];
      const f2 = document.getElementById('f2').files?.[0];
      if (!f1 || !f2) return;
      FILES.f1Name = f1.name; FILES.f2Name = f2.name;
      const [b1, b2] = await Promise.all([f1.arrayBuffer(), f2.arrayBuffer()]);
      FILES.f1Bytes = b1; FILES.f2Bytes = b2;
      // (Your existing postMessage happens right after this in your code)
    });

    const map = L.map('map', { zoomControl:true }).setView([39.1031, -84.5120], 12);

    // Basemaps
    const baseLayers = {
      street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution:"&copy; OpenStreetMap"
      }),
      aerial: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri'
      })
    };
    let activeBase = null;
    function setBasemap(which){
      if (activeBase) map.removeLayer(activeBase);
      if (which === 'none'){ activeBase = null; return; }
      activeBase = baseLayers[which] || baseLayers.street;
      activeBase.addTo(map);
    }
    setBasemap('street');
    document.getElementById('basemapSelect').addEventListener('change', (e)=> setBasemap(e.target.value));

    map.addControl(new (L.Control.extend({ onAdd(){ return document.getElementById('legend').content.firstElementChild.cloneNode(true); } }))({ position:"bottomleft" }));

    let layers = {
      nodes: { unchanged: L.layerGroup().addTo(map), changed: L.layerGroup().addTo(map), added: L.layerGroup().addTo(map), removed: L.layerGroup().addTo(map) },
      links: { unchanged: L.layerGroup().addTo(map), changed: L.layerGroup().addTo(map), added: L.layerGroup().addTo(map), removed: L.layerGroup().addTo(map) },
      subs:  { unchanged: L.layerGroup().addTo(map), changed: L.layerGroup().addTo(map), added: L.layerGroup().addTo(map), removed: L.layerGroup().addTo(map) },
      select: L.layerGroup().addTo(map)
    };
    const C = { unchanged:"#7f8c8d", changed:"#f39c12", added:"#2ecc71", removed:"#e74c3c", select:"#00FFFF" };

    function resetLayers() {
      Object.values(layers).forEach(groupSet=>{
        if (groupSet instanceof L.LayerGroup) { groupSet.clearLayers(); return; }
        Object.values(groupSet).forEach(g=>g.clearLayers());
      });
    }

    function xyToLatLng(x, y) {
      const [lon, lat] = proj4("EPSG:3735", "EPSG:4326", [x, y]);
      return [lat, lon];
    }

    let LAST = { json:null, currentSection:null };

    const secType = (sec) => (["JUNCTIONS","OUTFALLS","DIVIDERS","STORAGE"].includes(sec) ? "nodes" :
                              ["CONDUITS","PUMPS","ORIFICES","WEIRS","OUTLETS"].includes(sec) ? "links" :
                              sec==="SUBCATCHMENTS" ? "subs" : null);

    function buildSets(diffs, renames) {
      const sets = {
        nodes:{added:new Set(), removed:new Set(), changed:new Set(), base:new Set()},
        links:{added:new Set(), removed:new Set(), changed:new Set(), base:new Set()},
        subs:{added:new Set(), removed:new Set(), changed:new Set(), base:new Set()}
      };
      for (const [sec, d] of Object.entries(diffs)) {
        const t = secType(sec); if (!t) continue;
        Object.keys(d.added || {}).forEach(id => sets[t].added.add(id));
        Object.keys(d.removed || {}).forEach(id => sets[t].removed.add(id));
        Object.keys(d.changed || {}).forEach(id => sets[t].changed.add(id));
      }
      for (const [sec, mapping] of Object.entries(renames||{})) {
        const t = secType(sec); if (!t) continue;
        Object.keys(mapping).forEach(oldId => sets[t].changed.add(oldId));
      }
      return sets;
    }

    // Labels layer + helpers
    const labelsLayer = L.layerGroup().addTo(map);

    function midOfLine(coords){
      if (!coords || coords.length === 0) return null;
      if (coords.length === 1) return coords[0];
      const segs = [];
      let total = 0;
      for (let i=1; i<coords.length; i++){
        const a = coords[i-1], b = coords[i];
        const dx = b[0] - a[0], dy = b[1] - a[1];
        const len = Math.hypot(dx, dy);
        segs.push({a, b, len});
        total += len;
      }
      const half = total / 2;
      let acc = 0;
      for (const s of segs){
        if (acc + s.len >= half){
          const t = (half - acc) / (s.len || 1);
          return [ s.a[0] + t*(s.b[0]-s.a[0]), s.a[1] + t*(s.b[1]-s.a[1]) ];
        }
        acc += s.len;
      }
      return coords[Math.floor(coords.length/2)];
    }

    function centroidOfPoly(coords){
      if (!coords || coords.length === 0) return null;
      let x = 0, y = 0;
      for (const p of coords){ x += p[0]; y += p[1]; }
      return [x/coords.length, y/coords.length];
    }

    function drawLabels(json){
      labelsLayer.clearLayers();
      if (!document.getElementById('labelsToggle').checked) return;

      const geom = json.geometry;

      // Nodes
      const nodeKeys = new Set([...(Object.keys(geom.nodes2||{})), ...(Object.keys(geom.nodes1||{}))]);
      nodeKeys.forEach(id=>{
        const xy = (geom.nodes2 && geom.nodes2[id]) || (geom.nodes1 && geom.nodes1[id]);
        if (!xy) return;
        const ll = xyToLatLng(xy[0], xy[1]);
        L.marker(ll, {
          icon: L.divIcon({ className:'map-label', html: id, iconSize: null }),
          interactive: false
        }).addTo(labelsLayer);
      });

      // Links
      const linkKeys = new Set([...(Object.keys(geom.links2||{})), ...(Object.keys(geom.links1||{}))]);
      linkKeys.forEach(id=>{
        const coords = (geom.links2 && geom.links2[id]) || (geom.links1 && geom.links1[id]);
        if (!coords || coords.length === 0) return;
        const mid = midOfLine(coords);
        const ll = xyToLatLng(mid[0], mid[1]);
        L.marker(ll, {
          icon: L.divIcon({ className:'map-label', html: id, iconSize: null }),
          interactive: false
        }).addTo(labelsLayer);
      });

      // Subs
      const subKeys = new Set([...(Object.keys(geom.subs2||{})), ...(Object.keys(geom.subs1||{}))]);
      subKeys.forEach(id=>{
        const coords = (geom.subs2 && geom.subs2[id]) || (geom.subs1 && geom.subs1[id]);
        if (!coords || coords.length === 0) return;
        const c = centroidOfPoly(coords);
        const ll = xyToLatLng(c[0], c[1]);
        L.marker(ll, {
          icon: L.divIcon({ className:'map-label', html: id, iconSize: null }),
          interactive: false
        }).addTo(labelsLayer);
      });
    }

    document.getElementById('labelsToggle').addEventListener('change', ()=>{
      if (!LAST.json) return;
      drawLabels(LAST.json);
    });

    function drawGeometry(json) {
      resetLayers();
      const geom = json.geometry;
      const sets = buildSets(json.diffs, json.renames);

      const collectBase = (obj1,obj2)=> new Set([...Object.keys(obj1||{}), ...Object.keys(obj2||{})]);
      sets.nodes.base = collectBase(geom.nodes1, geom.nodes2);
      sets.links.base = collectBase(geom.links1, geom.links2);
      sets.subs.base  = collectBase(geom.subs1,  geom.subs2);

      const unchanged = {
        nodes:new Set([...sets.nodes.base].filter(x=>!sets.nodes.added.has(x)&&!sets.nodes.removed.has(x)&&!sets.nodes.changed.has(x))),
        links:new Set([...sets.links.base].filter(x=>!sets.links.added.has(x)&&!sets.links.removed.has(x)&&!sets.links.changed.has(x))),
        subs: new Set([...sets.subs.base ].filter(x=>!sets.subs.added.has(x) &&!sets.subs.removed.has(x) &&!sets.subs.changed.has(x)))
      };

      const drawNode=(id,xy,color,target)=>{ const ll=xyToLatLng(xy[0],xy[1]); L.circleMarker(ll,{radius:4,color,fill:true,fillOpacity:.9}).bindPopup(`${target.toUpperCase()} NODE ${id}`).addTo(layers.nodes[target]); };
      const drawLink=(id,coords,color,target)=>{ const ll=coords.map(p=>xyToLatLng(p[0],p[1])); L.polyline(ll,{color,weight:3,opacity:.95}).bindPopup(`${target.toUpperCase()} LINK ${id}`).addTo(layers.links[target]); };
      const drawSub=(id,coords,color,target)=>{ const ll=coords.map(p=>xyToLatLng(p[0],p[1])); L.polygon(ll,{color,weight:2,fill:true,fillOpacity:.25}).bindPopup(`${target.toUpperCase()} SUB ${id}`).addTo(layers.subs[target]); };

      for (const id of unchanged.nodes) if (geom.nodes1?.[id]) drawNode(id, geom.nodes1[id], C.unchanged, "unchanged");
      for (const id of sets.nodes.removed) if (geom.nodes1?.[id]) drawNode(id, geom.nodes1[id], C.removed, "removed");
      for (const id of unchanged.links) if (geom.links1?.[id]) drawLink(id, geom.links1[id], C.unchanged, "unchanged");
      for (const id of sets.links.removed) if (geom.links1?.[id]) drawLink(id, geom.links1[id], C.removed, "removed");
      for (const id of unchanged.subs) if (geom.subs1?.[id]) drawSub(id, geom.subs1[id], C.unchanged, "unchanged");
      for (const id of sets.subs.removed) if (geom.subs1?.[id]) drawSub(id, geom.subs1[id], C.removed, "removed");

      for (const id of sets.nodes.changed) { const xy=geom.nodes2?.[id]; if (xy) drawNode(id, xy, C.changed, "changed"); }
      for (const id of sets.nodes.added) if (geom.nodes2?.[id]) drawNode(id, geom.nodes2[id], C.added, "added");
      for (const id of sets.links.changed) { const ll=geom.links2?.[id]; if (ll) drawLink(id, ll, C.changed, "changed"); }
      for (const id of sets.links.added) if (geom.links2?.[id]) drawLink(id, geom.links2[id], C.added, "added");
      for (const id of sets.subs.changed) { const poly=geom.subs2?.[id]; if (poly) drawSub(id, poly, C.changed, "changed"); }
      for (const id of sets.subs.added) if (geom.subs2?.[id]) drawSub(id, geom.subs2[id], C.added, "added");

      const anyLL=[];
      const pushAll=(g)=>{ if(!g) return; Object.values(g).forEach(v=>{ if(Array.isArray(v)&&v.length&&Array.isArray(v[0])){ v.forEach(p=>anyLL.push(xyToLatLng(p[0],p[1])));} else if(Array.isArray(v)){ anyLL.push(xyToLatLng(v[0],v[1])); }}); };
      pushAll(geom.nodes1); pushAll(geom.nodes2); pushAll(geom.links1); pushAll(geom.links2); pushAll(geom.subs1); pushAll(geom.subs2);
      if (anyLL.length) map.fitBounds(L.latLngBounds(anyLL), { padding:[20,20] });

      // Redraw labels after geometry update
      drawLabels(json);
    }

    function renderSummary(rows){
      const host = document.getElementById('summary');
      if (!rows?.length){ host.textContent="No differences."; return; }
      let html = '<table style="width:100%; border-collapse:collapse;"><thead><tr><th>Section</th><th>Added</th><th>Removed</th><th>Changed</th></tr></thead><tbody>';
      for (const r of rows) html += `<tr><td>${r.Section}</td><td>${r.AddedCount}</td><td>${r.RemovedCount}</td><td>${r.ChangedCount}</td></tr>`;
      html += '</tbody></table>';
      host.innerHTML = html;
    }

    function groupHydroSummary(d) {
      const allKeys = new Set([
        ...Object.keys(d.added || {}),
        ...Object.keys(d.removed || {}),
        ...Object.keys(d.changed || {})
      ]);
      const grouped = new Map();
      for (const k of allKeys) {
        const parts = k.split(" ");
        const hydro = parts[0] || "";
        const month = parts[1] || "";
        const gkey = `${hydro} ${month}`;
        if (!grouped.has(gkey)) grouped.set(gkey, new Set());
        const s = grouped.get(gkey);
        if (d.added && (k in d.added)) s.add("Added");
        if (d.removed && (k in d.removed)) s.add("Removed");
        if (d.changed && (k in d.changed)) s.add("Changed");
      }
      const rows = [];
      for (const [gkey, set] of grouped.entries()) {
        const [hydro, month] = gkey.split(" ");
        rows.push({ id: gkey, hydro, month, changeType: [...set].sort().join(", ") || "—" });
      }
      rows.sort((a,b)=> (a.hydro+b.month).localeCompare(b.hydro+b.month));
      return rows;
    }

    function renderSections(json){
      const diffs = json.diffs || {};
      const cont = document.getElementById('sections');
      const items = [];
      for (const sec of Object.keys(diffs).sort()){
        const d = diffs[sec];
        const added   = Object.keys(d.added || {}).length;
        const removed = Object.keys(d.removed || {}).length;
        const changed = Object.keys(d.changed || {}).length;
        items.push({ sec, added, removed, changed });
      }
      if (!items.length){ cont.textContent = "No sections with differences."; return; }
      cont.innerHTML = "";
      items.forEach(({sec, added, removed, changed})=>{
        const div = document.createElement('div');
        div.className = 'sec';
        div.dataset.sec = sec;
        div.innerHTML = `<span>${sec}</span>
          <span class="counts">
            <span class="pill added">+${added}</span>
            <span class="pill removed">-${removed}</span>
            <span class="pill changed">⚙${changed}</span>
          </span>`;
        div.onclick = ()=>{
          document.querySelectorAll('.sec').forEach(n=>n.classList.remove('active'));
          div.classList.add('active');
          LAST.currentSection = sec;
          document.getElementById('currentSectionLabel').textContent = sec;
          renderTableFor(sec);
        };
        cont.appendChild(div);
      });
      cont.firstChild?.click();
    }

    function passChangeFilter(changeType){
      const m = { Added:'fAdded', Removed:'fRemoved', Changed:'fChanged' };
      const id = m[changeType] || null;
      if (!id) return true;
      return document.getElementById(id).checked;
    }

    function renderTableFor(sec){
      const table = document.getElementById('table');
      const { diffs, headers } = LAST.json;
      const d = diffs[sec] || { added:{}, removed:{}, changed:{} };
      const q = document.getElementById('search').value.trim().toLowerCase();

      // HYDROGRAPHS special
      if (sec === "HYDROGRAPHS") {
        const rows = groupHydroSummary(d);
        const hdrs = ["Hydrograph","Month","ChangeType"];

        let thead = `<thead><tr><th style="width:180px">ElementID</th><th style="width:110px">Change</th>`;
        for (const h of hdrs) thead += `<th>${escapeHtml(h)}</th>`;
        thead += `</tr></thead>`;

        const filtered = q
          ? rows.filter(r => (`${r.id} ${r.changeType}`).toLowerCase().includes(q))
          : rows;

        const body = [];
        for (const r of filtered) {
          const type = r.changeType === "Added" || r.changeType === "Removed" ? r.changeType : "Changed";
          const pill = type.toLowerCase();
          let tr = `<tr class="row" data-hydro="${escapeHtml(r.hydro)}" data-month="${escapeHtml(r.month)}">`;
          tr += `<td>${escapeHtml(`${r.hydro} ${r.month}`)}</td>`;
          tr += `<td><span class="pill ${pill}">${type}</span></td>`;
          tr += `<td>${escapeHtml(r.hydro)}</td><td>${escapeHtml(r.month)}</td><td>${escapeHtml(r.changeType)}</td>`;
          tr += `</tr>`;
          body.push(tr);
        }

        table.innerHTML = thead + `<tbody>${body.join("") || `<tr><td colspan="${hdrs.length+2}" style="color:#666;font-style:italic;">No rows match.</td></tr>`}</tbody>`;

        table.querySelectorAll('tbody tr').forEach((tr)=>{
          const hydro = tr.dataset.hydro;
          const month = tr.dataset.month;
          tr.onclick  = ()=> highlightElement(sec, `${hydro} ${month}`);
          tr.ondblclick = ()=> openDetail("HYDROGRAPHS", `${hydro} ${month}`);
        });
        return;
      }

      // Default path
      const hdrs = headers[sec] || [];
      const hdrsLabeled = relabelHeaders(sec, hdrs);

      const rows = [];
      const push = (type, id, oldArr, newArr) => rows.push({type,id,oldArr:(oldArr||[]),newArr:(newArr||[])});

      for (const [id, arr] of Object.entries(d.added || {})) if (passChangeFilter('Added')) push('Added', id, [], arr);
      for (const [id, arr] of Object.entries(d.removed || {})) if (passChangeFilter('Removed')) push('Removed', id, arr, []);
      for (const [id, pair] of Object.entries(d.changed || {})) if (passChangeFilter('Changed')) push('Changed', id, pair[0], pair[1]);

      const filt = q ? rows.filter(r => (r.id+' '+r.type+' '+r.oldArr.join(' ')+' '+r.newArr.join(' ')).toLowerCase().includes(q)) : rows;

      let thead = `<thead><tr><th style="width:180px">ElementID</th><th style="width:110px">Change</th>`;
      for (const h of hdrsLabeled) thead += `<th>${escapeHtml(h)}</th>`;
      thead += `</tr></thead>`;

      const tbodyParts = [];
      for (const r of filt){
        const pill = r.type.toLowerCase();
        let tr = `<tr class="row">`;
        tr += `<td>${escapeHtml(r.id)}</td>`;
        tr += `<td><span class="pill ${pill}">${r.type}</span></td>`;

        const len = hdrsLabeled.length;
        let oldA, newA;

        if (sec === "HYDROGRAPHS") {
          const parts = r.id.split(' ');
          const hydrograph = parts[0] || '';
          const month = parts[1] || '';
          const response = parts.slice(2).join(' ') || '';
          oldA = [hydrograph, month, response, ...r.oldArr];
          newA = [hydrograph, month, response, ...r.newArr];
        } else {
          oldA = [r.id, ...r.oldArr];
          newA = [r.id, ...r.newArr];
        }

        while (oldA.length < len) oldA.push("");
        while (newA.length < len) newA.push("");

        for (let i=0;i<len;i++){
          const ov = oldA[i] ?? "";
          const nv = newA[i] ?? "";
          if (r.type === "Added")      tr += `<td class="addedCell">${escapeHtml(nv)}</td>`;
          else if (r.type === "Removed") tr += `<td class="removedCell">${escapeHtml(ov)}</td>`;
          else tr += (ov !== nv)
            ? `<td><span class="diff">${escapeHtml(ov)} <span class="arrow">→</span> ${escapeHtml(nv)}</span></td>`
            : `<td>${escapeHtml(nv)}</td>`;
        }
        tr += `</tr>`;
        tbodyParts.push(tr);
      }

      table.innerHTML = thead + `<tbody>${tbodyParts.join("") || `<tr><td colspan="${hdrsLabeled.length+2}" style="color:#666;font-style:italic;">No rows match.</td></tr>`}</tbody>`;

      table.querySelectorAll('tbody tr').forEach((tr)=>{
        const id = tr.children[0]?.textContent || "";
        tr.onclick = ()=> highlightElement(sec, id);
        tr.ondblclick = ()=> openDetail(sec, id);
      });
    }

    function escapeHtml(s){ return (s||"").replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }

    function highlightElement(section, id){
      layers.select.clearLayers();
      const t = secType(section);
      if (!t) return;

      const g1 = LAST.json.geometry[ t === 'nodes' ? 'nodes1' : t === 'links' ? 'links1' : 'subs1' ];
      const g2 = LAST.json.geometry[ t === 'nodes' ? 'nodes2' : t === 'links' ? 'links2' : 'subs2' ];

      const geo = (g2 && g2[id] !== undefined) ? g2[id] : (g1 ? g1[id] : undefined);

      if (!geo) return;
      if (t === 'nodes'){
        const ll = xyToLatLng(geo[0], geo[1]);
        L.circleMarker(ll, { radius:10, color:C.select, weight:4, fill:false, opacity:.95 }).addTo(layers.select);
        map.panTo(ll, { animate:true });
      } else if (t === 'links') {
        const ll = geo.map(p=>xyToLatLng(p[0],p[1]));
        L.polyline(ll, { color:C.select, weight:8, opacity:.8 }).addTo(layers.select);
        map.fitBounds(L.latLngBounds(ll), { padding:[20,20] });
      } else if (t === 'subs'){
        const ll = geo.map(p=>xyToLatLng(p[0],p[1]));
        L.polygon(ll, { color:C.select, weight:5, fill:false, opacity:.95 }).addTo(layers.select);
        map.fitBounds(L.latLngBounds(ll), { padding:[20,20] });
      }
    }

    const worker = new Worker("worker.js");
    function setStatus(s){ document.getElementById('status').textContent = s; }
    worker.onmessage = (ev)=>{
      const { type, payload, error } = ev.data || {};
      if (type === "ready") { setStatus("Ready."); return; }
      if (type === "progress") { setStatus(payload); return; }
      if (type === "error") { setStatus(error || "Error"); alert(error); return; }
      if (type === "result") {
        try {
          const json = JSON.parse(payload);
          LAST.json = json;
          renderSummary(json.summary);
          renderSections(json);
          drawGeometry(json);
          setStatus("Done.");
        } catch (e) {
          console.error(e);
          setStatus("Failed to parse result.");
          alert("Failed to parse result JSON.");
        }
      }
    };
    worker.postMessage({ type:"init" });

    document.getElementById('go').addEventListener('click', async ()=>{
      const f1 = document.getElementById('f1').files?.[0];
      const f2 = document.getElementById('f2').files?.[0];
      if (!f1 || !f2) { alert("Please choose both INP files."); return; }
      setStatus("Reading files…");
      const [b1, b2] = await Promise.all([f1.arrayBuffer(), f2.arrayBuffer()]);
      setStatus("Running comparison…");
      worker.postMessage({ type:"compare", file1: b1, file2: b2 }, [b1, b2]);
    });

    ["fAdded","fRemoved","fChanged","search"].forEach(id=>{
      document.getElementById(id).addEventListener(id==="search"?"input":"change", ()=>{
        if (!LAST.currentSection) return;
        renderTableFor(LAST.currentSection);
      });
    });

    function openDetail(section, id){
      const { diffs, headers, renames, hydrographs } = LAST.json || {};
      const d = diffs?.[section] || { added:{}, removed:{}, changed:{} };
      const titleEl = document.getElementById('modalTitle');
      const metaEl = document.getElementById('modalMeta');
      const grid = document.getElementById('modalGrid');
      const onlyChangedBox = document.getElementById('onlyChangedBox');

      // HYDROGRAPHS drill-down
      if (section === "HYDROGRAPHS" && id.includes(" ")) {
        const [hydro, month] = id.split(" ");
        titleEl.textContent = `HYDROGRAPH · ${hydro} · ${month}`;
        grid.innerHTML = "";

        const params = ["R","T","K","Dmax","Drecov","Dinit"];
        const responses = ["Short","Medium","Long"];

        const h1 = (hydrographs?.file1 || {});
        const h2 = (hydrographs?.file2 || {});
        function getVals(dict, resp) {
          return (dict[`${hydro} ${month} ${resp}`] || ["","","","","",""]).slice(0,6);
        }

        function fmtNum(x){
          const v = Number(x);
          if (!isFinite(v)) return (x && x !== "") ? escapeHtml(x) : "—";
          const s = v.toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
          return s === "-0.000" ? "0.000" : s;
        }

        function deltaCell(ov, nv){
          if ((ov ?? "") === (nv ?? "")) return `<span class="num">${fmtNum(nv)}</span>`;
          const vo = Number(ov), vn = Number(nv);
          const hasNums = isFinite(vo) && isFinite(vn);
          const delta = hasNums ? vn - vo : null;
          const dTxt = hasNums ? ` <span class="plusminus">(${delta >= 0 ? "+" : ""}${fmtNum(delta)})</span>` : "";
          const oTxt = (ov !== "" && ov !== undefined) ? fmtNum(ov) : "—";
          const nTxt = (nv !== "" && nv !== undefined) ? fmtNum(nv) : "—";
          return `<span class="delta"><span class="old">${oTxt}</span><span class="arrow">→</span><span class="diff">${nTxt}</span>${dTxt}</span>`;
        }

        const tbl = document.createElement("table");
        tbl.className = "modal-hydro";
        tbl.innerHTML = `<thead>
          <tr><th class="resp">Response</th>${params.map(p=>`<th>${p}</th>`).join("")}</tr>
        </thead><tbody></tbody>`;
        const tbody = tbl.querySelector("tbody");

        const showOnlyChanged = () => onlyChangedBox.checked;

        for (const resp of responses) {
          const oldVals = getVals(h1, resp);
          const newVals = getVals(h2, resp);
          const rowHasChange = oldVals.some((ov,i)=> (ov||"") !== (newVals[i]||""));
          if (showOnlyChanged() && !rowHasChange) continue;

          const tr = document.createElement("tr");
          tr.innerHTML = `<td style="padding:6px 8px;font-weight:600;">${resp}</td>` +
            params.map((_,i)=>{
              const ov = oldVals[i] || "";
              const nv = newVals[i] || "";
              return `<td>${deltaCell(ov, nv)}</td>`;
            }).join("");
          tbody.appendChild(tr);
        }

        metaEl.innerHTML = `<span class="tag">Hydrograph</span>`;
        grid.appendChild(tbl);
        onlyChangedBox.onchange = ()=> openDetail(section, id);
        document.getElementById('modalBackdrop').style.display = 'flex';
        return;
      }

      // Default (non-HYDROGRAPHS) with relabeled headers for INFILTRATION
      const hdrsRaw = (headers?.[section] || []).slice();
      const hdrsLabeled = relabelHeaders(section, hdrsRaw);

      const isAdded   = d.added && Object.prototype.hasOwnProperty.call(d.added, id);
      const isRemoved = d.removed && Object.prototype.hasOwnProperty.call(d.removed, id);
      const changeType = isAdded ? 'Added' : isRemoved ? 'Removed' : 'Changed';

      let oldArr = isAdded   ? [] : isRemoved ? (d.removed[id] || []) : (d.changed[id]?.[0] || []);
      let newArr = isRemoved ? [] : isAdded   ? (d.added[id]   || []) : (d.changed[id]?.[1] || []);

      titleEl.textContent = `${section} · ${id}`;
      const renameTo = renames?.[section]?.[id];
      metaEl.innerHTML = `<span class="tag">${changeType}</span>${renameTo ? `<span class="tag" style="margin-left:6px">Renamed ↦ ${renameTo}</span>`:''}`;

      const maxLen = Math.max(oldArr.length, newArr.length) + 1;
      while (hdrsLabeled.length < maxLen) hdrsLabeled.push(`Field ${hdrsLabeled.length+1}`);

      grid.innerHTML = `
        <div class="hdr">Field</div>
        <div class="hdr">Old</div>
        <div class="hdr">New</div>
      `;
      const showOnlyChanged = () => onlyChangedBox.checked;
      const pushRow = (label, oldV, newV)=>{
        const changed = (oldV||"") !== (newV||"");
        if (showOnlyChanged() && !changed) return;
        const oldCell = changed ? `<span class="cell-changed">${escapeHtml(oldV||"")}</span>` : escapeHtml(oldV||"");
        const newCell = changed ? `<span class="cell-changed">${escapeHtml(newV||"")}</span>` : escapeHtml(newV||"");
        grid.insertAdjacentHTML('beforeend', `<div>${escapeHtml(label)}</div><div>${oldCell}</div><div>${newCell}</div>`);
      };
      pushRow(hdrsLabeled[0] || "ID", id, id);
      for (let i=1;i<maxLen;i++) pushRow(hdrsLabeled[i] || `Field ${i}`, oldArr[i-1], newArr[i-1]);

      onlyChangedBox.onchange = ()=> openDetail(section, id);
      document.getElementById('modalBackdrop').style.display = 'flex';
    }

    function closeModal(){ document.getElementById('modalBackdrop').style.display='none'; }

    function copyRowJSON(){
      const section = LAST.currentSection;
      if (!section) return;
      const d = LAST.json?.diffs?.[section] || {};
      const rawTitle = document.getElementById('modalTitle').textContent;
      const parts = rawTitle.split('·').map(s=>s.trim());
      const id = parts[parts.length-1];

      let oldArr = [], newArr = [];
      if (d.added && Object.prototype.hasOwnProperty.call(d.added, id)) {
        newArr = d.added[id] || [];
      } else if (d.removed && Object.prototype.hasOwnProperty.call(d.removed, id)) {
        oldArr = d.removed[id] || [];
      } else if (d.changed && Object.prototype.hasOwnProperty.call(d.changed, id)) {
        oldArr = d.changed[id]?.[0] || [];
        newArr = d.changed[id]?.[1] || [];
      }

      const entry = {
        section,
        id,
        headers: relabelHeaders(section, (LAST.json?.headers?.[section] || [])),
        old: oldArr,
        new: newArr,
      };
      navigator.clipboard.writeText(JSON.stringify(entry, null, 2));
      alert("Row JSON copied.");
    }
  </script>
</body>
</html>
